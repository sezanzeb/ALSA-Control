#!/usr/bin/python3
# -*- coding: utf-8 -*-
# ALSA-Control - ALSA configuration interface
# Copyright (C) 2020 sezanzeb <proxima@hip70890b.de>
#
# This file is part of ALSA-Control.
#
# ALSA-Control is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# ALSA-Control is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with ALSA-Control.  If not, see <https://www.gnu.org/licenses/>.


"""Displays notifications for the current volume."""


import sys
from argparse import ArgumentParser

from dbus import service
from dbus.mainloop.glib import DBusGMainLoop
import dbus.mainloop.glib
import gi
gi.require_version('Notify', '0.7')
gi.require_version('GLib', '2.0')
gi.require_version('Gio', '2.0')
gi.require_version('Gtk', '3.0')
from gi.repository import Notify, GLib

from alsacontrol.asoundrc import setup
from alsacontrol.logger import logger, update_verbosity
from alsacontrol.alsa import set_volume, get_volume, toggle_mute, is_muted
from alsacontrol.bindings import print_info


Notify.init('ALSA-Control')


class Daemon(service.Object):
    """Waits for volume changes over alsacontrol and displays them.

    This needs to be done by a daemon, so that it can hold a state and
    replace the old notification with the outdated volume instead of
    stacking them.
    """
    def __init__(self, *args, **kwargs):
        self._notification_id = None
        self.exponent = 3

        # fine grained current mixer volume to better convert from linear
        # to perceived volume without having to worry about rounding.
        # Especially going down by 10% and up by 10% should end up at the
        # initial volume.
        # alsamixer only provides a resolution of 100 and softvol of max 1048
        self.perceived_volume = self.to_perceived_volume(get_volume())

        super().__init__(*args, **kwargs)

    def check_volume_integrity(self):
        """If the internal volume is out of touch with the mixer, reset."""
        expected_mixer_volume = self.to_mixer_volume(self.perceived_volume)
        actual_mixer_volume = get_volume()
        if expected_mixer_volume - actual_mixer_volume > 0.1:
            logger.debug(
                'Resetting the internal volume '
                '(%s) to the mixers actual value (%s)',
                expected_mixer_volume,
                actual_mixer_volume
            )
            self.perceived_volume = self.to_perceived_volume(get_volume())

    def to_perceived_volume(self, volume):
        """For a mixer volume of 0.5, figure out the perceived volume."""
        return max(0, min(1, volume ** self.exponent))

    def to_mixer_volume(self, volume):
        """For a perceived volume of 0.5, figure out the mixers volume."""
        return max(0, min(1, volume ** (1 / self.exponent)))

    def show_notification(self, text, icon, hints):
        """Display a notification in the GUI that replaces the old one.

        If hints contains a 'value' key of type GLib.Variant.new_int32,
        it will display a progress bar instead of text. Useful for volume.
        """
        notification = Notify.Notification.new('', text, icon)

        if self._notification_id is not None:
            notification.props.id = self._notification_id

        for key in hints:
            notification.set_hint(key, hints[key])

        notification.show()
        self._notification_id = notification.props.id

    @dbus.service.method(
        'com.alsacontrol.Interface',
        in_signature='d'
    )
    def change_volume(self, volume):
        """Show the specified volume in a desktop notification

        Parameters
        ----------
        volume : int
            perceived volume change between -1 and +1
        """
        self.check_volume_integrity()
        logger.debug('Received volume change of %s', volume)
        perceived_new = max(0, min(1, self.perceived_volume + volume))
        mixer_new = self.to_mixer_volume(perceived_new)
        self.perceived_volume = perceived_new
        set_volume(mixer_new)
        self.notify(perceived_new, is_muted())

    @dbus.service.method(
        'com.alsacontrol.Interface'
    )
    def toggle_muted(self):
        """Mute if unmuted, unmute if muted."""
        logger.debug('Received command to toggle mute')
        muted = toggle_mute()
        self.notify(self.perceived_volume, muted)

    def notify(self, volume, muted):
        """Display a pretty notification for volume and mute state."""
        # various icons to visualize the volume
        if muted or volume <= 0:
            icon = 'audio-volume-muted'
        elif volume < 0.33:
            icon = 'audio-volume-low'
        elif volume < 0.66:
            icon = 'audio-volume-medium'
        else:
            icon = 'audio-volume-high'

        volume_string = '{}%'.format(int(volume * 100))

        self.show_notification(volume_string, icon, {
            'value': GLib.Variant.new_int32(volume * 100)
        })

        muted = 'muted' if muted else 'unmuted'
        logger.info('Changing the volume to %s, %s', volume_string, muted)


if __name__ == '__main__':
    parser = ArgumentParser()
    parser.add_argument(
        '-d', '--debug', action='store_true', dest='debug',
        help='Displays additional debug information',
        default=False
    )
    options = parser.parse_args(sys.argv[1:])
    update_verbosity(options.debug)

    print_info()

    setup()

    # make sure our .asoundrc is included so that the mixer name exists
    session_bus = dbus.SessionBus(mainloop=DBusGMainLoop())
    name = dbus.service.BusName('com.alsacontrol.Volume', session_bus)
    Daemon(session_bus, '/')

    mainloop = GLib.MainLoop()
    mainloop.run()
