#!/usr/bin/python3
# -*- coding: utf-8 -*-
# ALSA-Control - ALSA configuration interface
# Copyright (C) 2020 sezanzeb <proxima@hip70890b.de>
#
# This file is part of ALSA-Control.
#
# ALSA-Control is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# ALSA-Control is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with ALSA-Control.  If not, see <https://www.gnu.org/licenses/>.


"""Displays notifications for the current volume."""


import sys
from argparse import ArgumentParser

import alsaaudio
from dbus import service
from dbus.mainloop.glib import DBusGMainLoop
import dbus.mainloop.glib
import gi
gi.require_version('Notify', '0.7')
gi.require_version('GLib', '2.0')
from gi.repository import Notify, GLib

from alsacontrol.asoundrc import setup_asoundrc
from alsacontrol.logger import logger, update_verbosity, log_info, \
    add_filehandler
from alsacontrol.alsa import set_volume, get_volume, toggle_mute, \
    is_muted, to_perceived_volume, to_mixer_volume, OUTPUT_MUTE
from alsacontrol.bindings import get_volume_icon, get_current_card, \
    only_with_existing_output
from alsacontrol.dbus import set_bus
from alsacontrol.config import output_exists


Notify.init('ALSA-Control')


class Daemon(service.Object):
    """Waits for volume changes over alsacontrol and displays them.

    This needs to be done by a daemon, so that it can hold a state and
    replace the old notification with the outdated volume instead of
    stacking them.
    """
    def __init__(self, *args, **kwargs):
        self._notification_id = None

        # fine grained current mixer volume to better convert from linear
        # to perceived volume without having to worry about rounding.
        # Especially going down by 10% and up by 10% should end up at the
        # initial volume. alsamixer only provides a resolution of 100
        # and softvol of max 1048
        if output_exists():
            self.perceived_volume = get_volume(alsaaudio.PCM_PLAYBACK, True)
        else:
            self.perceived_volume = 0

        super().__init__(*args, **kwargs)

    @only_with_existing_output
    def check_volume_integrity(self):
        """If the internal volume is out of touch with the mixer, reset.

        If the volume handling is broken, return None. Otherwise True.
        """
        expected_mixer_volume = to_mixer_volume(self.perceived_volume)
        actual_mixer_volume = get_volume(alsaaudio.PCM_PLAYBACK)

        if abs(expected_mixer_volume - actual_mixer_volume) > 0.01:
            logger.debug(
                'Resetting the internal volume '
                '(%s) to the mixers actual value (%s)',
                expected_mixer_volume,
                actual_mixer_volume
            )
            self.perceived_volume = to_perceived_volume(actual_mixer_volume)
        return True

    def show_notification(self, text, icon, hints, short=False):
        """Display a notification in the GUI that replaces the old one.

        Parameters
        ----------
        text : string
        icon : string
        hints : dict
            If hints contains a 'value' key of type GLib.Variant.new_int32,
            it will display a progress bar instead of text.
            Useful for volume.
        short : bool
            If True, the notification will go away faster.
        """
        notification = Notify.Notification.new('', text, icon)

        if self._notification_id is not None:
            notification.props.id = self._notification_id

        for key in hints:
            notification.set_hint(key, hints[key])

        if short:
            notification.set_timeout(200)

        notification.show()
        self._notification_id = notification.props.id

    @dbus.service.method(
        'com.alsacontrol.Interface',
        in_signature='d'
    )
    def change_volume(self, volume):
        """Show the specified volume in a desktop notification

        Parameters
        ----------
        volume : int
            perceived volume change between -1 and +1
        """
        if not output_exists('change_volume'):
            return

        logger.debug('Received volume change of %s', volume)

        self.check_volume_integrity()

        perceived_new = max(0, min(1, self.perceived_volume + volume))
        mixer_new = to_mixer_volume(perceived_new)
        self.perceived_volume = perceived_new
        set_volume(mixer_new, alsaaudio.PCM_PLAYBACK)
        self.notify(perceived_new, is_muted())

    @dbus.service.method(
        'com.alsacontrol.Interface'
    )
    def toggle_muted(self):
        """Mute if unmuted, unmute if muted."""
        if not output_exists('toggle_muted'):
            return

        logger.debug('Received command to toggle mute')
        muted = toggle_mute(OUTPUT_MUTE)
        self.notify(self.perceived_volume, muted)

    def notify(self, volume, muted):
        """Display a pretty notification for volume and mute state."""
        # various icons to visualize the volume
        icon = get_volume_icon(volume, muted)

        volume_string = f'{int(volume * 100)}%'

        self.show_notification(volume_string, icon, {
            'value': GLib.Variant.new_int32(volume * 100)
        }, short=True)

        muted = 'muted' if muted else 'unmuted'
        logger.info('Changing the volume to %s, %s', volume_string, muted)


if __name__ == '__main__':
    parser = ArgumentParser()
    parser.add_argument(
        '-d', '--debug', action='store_true', dest='debug',
        help='Displays additional debug information',
        default=False
    )
    options = parser.parse_args(sys.argv[1:])
    add_filehandler()
    update_verbosity(options.debug)

    set_bus(DBusGMainLoop())

    log_info()

    # log some errors if the selected card doesn't exist
    get_current_card('pcm_output')

    # make sure alsacontrols asoundrc is included so that the mixer exists
    setup_asoundrc()

    # discover mixers
    output_exists('Bindings')

    session_bus = dbus.SessionBus(mainloop=DBusGMainLoop())
    name = dbus.service.BusName('com.alsacontrol.Volume', session_bus)
    Daemon(session_bus, '/')

    mainloop = GLib.MainLoop()
    mainloop.run()
