#!/usr/bin/python3
# -*- coding: utf-8 -*-
# ALSA-Control - ALSA configuration interface
# Copyright (C) 2020 sezanzeb <proxima@hip70890b.de>
#
# This file is part of ALSA-Control.
#
# ALSA-Control is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# ALSA-Control is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with ALSA-Control.  If not, see <https://www.gnu.org/licenses/>.


"""User Interface."""


import os

from dbus.mainloop.glib import DBusGMainLoop
import alsaaudio
import gi
gi.require_version('Gtk', '3.0')
gi.require_version('GLib', '2.0')
from gi.repository import Gtk, GLib

from alsacontrol.alsa import get_volume, set_volume, set_mute, is_muted, \
    get_cards, OUTPUT_MUTE, INPUT_MUTE, get_level, play_silence, \
    record_to_nowhere
from alsacontrol.bindings import Bindings, get_volume_string, \
    get_volume_icon, get_error_advice, select_input_pcm, select_output_pcm, \
    get_current_card, eavesdrop_volume_notifications, \
    only_with_existing_input, only_with_existing_output
from alsacontrol.data import get_data_path
from alsacontrol.logger import logger
from alsacontrol.dbus import set_bus
from alsacontrol.pulse import is_pulse_running
from alsacontrol.config import output_exists, input_exists


class HandlerDisabled:
    """Safely modify a widget without causing handlers to be called.

    Use in a with statement.
    """
    def __init__(self, widget, event, handler):
        self.widget = widget
        self.handler = handler
        self.event = event
        self.was_connected = None

    def __enter__(self):
        try:
            self.widget.disconnect_by_func(
                self.handler
            )
            self.was_connected = True
        except TypeError:
            self.was_connected = False

    def __exit__(self, *_):
        if self.was_connected:
            self.widget.connect(
                self.event, self.handler
            )


class InputRow:
    """A single selectable input card with monitoring."""
    def __init__(self, card, select_callback):
        """Construct a row and add it to the list in the GUI."""
        self.card = card  # card that this row represents
        self.select_button = None
        self.input_level_monitor = None
        self.box = None
        self.vailid = True
        self.select_callback = select_callback
        self.select_handler_id = None
        self.put_together()

    def is_valid(self):
        """Check if this input works."""
        return self.input_level_monitor.valid

    def get_widget(self):
        """Return the widget that wraps all the widgets of the row."""
        return self.box

    def put_together(self):
        """Create all GTK widgets and the level monitor"""
        card = self.card
        level_bar = Gtk.ProgressBar()
        level_bar.set_valign(Gtk.Align.CENTER)

        input_level_monitor = InputLevel(card, level_bar, self)
        self.input_level_monitor = input_level_monitor
        if not input_level_monitor.valid:
            level_bar.destroy()
            return

        select_button = Gtk.ToggleButton()
        select_icon = Gtk.Image.new_from_icon_name(
            'object-select', Gtk.IconSize.BUTTON
        )
        select_button.set_image(select_icon)
        self.select_handler_id = select_button.connect(
            'clicked',
            lambda _: self.select_callback(card)
        )
        self.select_button = select_button

        pcm_name = Gtk.Label(label=card)
        pcm_name.set_xalign(0.0)

        box = Gtk.Box(
            orientation=Gtk.Orientation.HORIZONTAL,
            spacing=10
        )
        box.pack_start(select_button, expand=False, fill=True, padding=0)
        box.pack_start(pcm_name, expand=True, fill=True, padding=0)
        box.pack_start(level_bar, expand=False, fill=False, padding=0)
        box.set_margin_start(10)
        box.set_margin_end(22)
        box.show_all()
        self.box = box

    def stop_monitor(self):
        """Stop monitoring the input."""
        self.input_level_monitor.stop()

    def destroy(self):
        """Stop monitoring and destroy the row."""
        self.input_level_monitor.stop()
        self.box.destroy()

    def set_active(self, active):
        """Set if the button should be highlighted. Doesn't emit events."""
        if self.select_button.get_active() != active:
            self.select_button.handler_block(self.select_handler_id)
            self.select_button.set_active(active)
            self.select_button.handler_unblock(self.select_handler_id)


class InputLevel:
    """Shows smooth indicators for the input level."""
    def __init__(self, card, level_bar, window):
        """Get the input level and show it in the row of the card."""
        self.level_bar = level_bar
        self.window = window
        self.previous_level = 0
        self.card = card

        self.valid = True
        self.stopped = False
        self.pcm = None

        self.start_monitoring()

    def start_monitoring(self):
        """Start the loop to monitor the input level."""
        card = self.card
        if card == 'jack':
            card = 'alsacontrol-jack-input'
        else:
            card = f'sysdefault:CARD={card}'

        try:
            pcm = alsaaudio.PCM(
                type=alsaaudio.PCM_CAPTURE,
                device=card,
                # don't freeze when the device disappears
                mode=alsaaudio.PCM_NONBLOCK
            )
        except alsaaudio.ALSAAudioError:
            logger.error('Could not monitor the level of "%s"', card)
            self.valid = False
            return

        self.pcm = pcm
        GLib.timeout_add(1000 / 60, self.loop)

    def stop(self):
        """Stop monitoring the input level."""
        self.stopped = True

    def loop(self):
        """Refresh the input level of the row."""
        if self.stopped:
            return False

        new_level = get_level(self.pcm)
        if new_level is None:
            # try again
            return True
        # make silent signals more apparent
        new_level = new_level ** (1 / 2)

        # exponential smoothing
        new_level = (self.previous_level * 10 + new_level) / 11
        self.previous_level = new_level
        self.level_bar.set_fraction(new_level)
        # Keep the UI responsive
        Gtk.main_iteration()
        return True


class ALSAControlWindow:
    """User Interface."""
    def __init__(self):
        self.bindings = Bindings()

        self.input_levels = []
        self.input_rows = []

        gladefile = os.path.join(get_data_path(), 'alsacontrol.glade')
        builder = Gtk.Builder()
        builder.add_from_file(gladefile)
        builder.connect_signals(self)
        self.builder = builder

        self.card_selection = self.builder.get_object(
            'output_card_selection'
        )

        self.initialize_volume_slider()
        self.populate_output_cards_dropdown()
        self.populate_input_pcms()
        self.select_current_output()
        self.select_current_input()

        self.speaker_test_process = None

        window = builder.get_object('alsacontrol_window')
        window.show()
        self.window = window

        speaker_test_error = builder.get_object('speaker_test_error')
        speaker_test_error.hide()

        eavesdrop_volume_notifications(self.volume_changed_externally)

        if is_pulse_running():
            logger.error('Pulseaudio is running')
            builder.get_object('status_bar_text').set_text(
                'This app may not work correctly with Pulseaudio.\n'
                'Consider using pavucontrol instead.'
            )
            builder.get_object('status_bar').show()

        GLib.timeout_add(500, self.refresh_cards)

    """General Stuff"""

    @only_with_existing_output
    @only_with_existing_input
    def volume_changed_externally(self):
        """When the volume was changed by `alsacontrol`."""
        self.initialize_volume_slider()

        output_volume = get_volume(alsaaudio.PCM_PLAYBACK, nonlinear=True)
        output_muted = is_muted(OUTPUT_MUTE)
        self.refresh_icon_state('output', output_volume, output_muted)

        input_volume = get_volume(alsaaudio.PCM_PLAYBACK, nonlinear=True)
        input_muted = is_muted(INPUT_MUTE)
        self.refresh_icon_state('input', input_volume, input_muted)

    def on_close(self, *_):
        """Safely close the application."""
        self.bindings.stop_speaker_test()
        self.stop_input_levels()
        Gtk.main_quit()

    def refresh_cards(self):
        """Refresh the list of cards for both input and output."""
        if self.bindings.log_new_pcms():
            self.populate_output_cards_dropdown()
            self.populate_input_pcms()
        return True

    @only_with_existing_output
    @only_with_existing_input
    def initialize_volume_slider(self):
        """Reflect the current volume and mute state on each tab."""
        output_slider = self.builder.get_object('output_volume_slider_scale')
        output_volume = get_volume(alsaaudio.PCM_PLAYBACK, nonlinear=True) or 0
        output_slider.set_value(output_volume)
        output_muted = is_muted(OUTPUT_MUTE)
        self.refresh_icon_state('output', output_volume, output_muted)

        input_slider = self.builder.get_object('input_volume_slider_scale')
        input_volume = get_volume(alsaaudio.PCM_CAPTURE, nonlinear=True) or 0
        input_slider.set_value(input_volume)
        input_muted = is_muted(INPUT_MUTE)
        self.refresh_icon_state('input', input_volume, input_muted)

    def on_switch_page(self, notebook, page, page_num):
        """Handler to trigger when one of the tabs is clicked."""
        page_name = page.get_name()
        input_cards_scrolled_window = self.builder.get_object(
            'input_cards_scrolled_window'
        )
        if page_name == 'input_card_tab':
            input_cards_scrolled_window.show()
        else:
            # shrink the output tab height to the contents
            input_cards_scrolled_window.hide()

    def refresh_icon_state(self, tab, volume, muted):
        """Refresh icons and labels depending on mute and volume state.

        Parameters
        ----------
        tab : string
            one of 'output' or 'input'
        volume : float
            Current volume. Between 0 and 1
        muted : bool
            If audio can't currently play. True or False
        """
        volume_string = get_volume_string(volume, muted)
        volume_label = self.builder.get_object(f'{tab}_volume_current')
        volume_label.set_label(volume_string)

        mute_icon = self.builder.get_object(f'mute_{tab}')
        mute_icon.set_active(muted)

        volume_icon_name = get_volume_icon(volume, muted)
        volume_image = self.builder.get_object(f'{tab}_volume_icon')
        volume_image.set_from_icon_name(volume_icon_name, Gtk.IconSize.BUTTON)

    """Output"""

    def dropdown_handlers_disabled(self):
        """Safely modify dropdown contents."""
        return HandlerDisabled(
            self.card_selection, 'changed', self.on_output_card_selected
        )

    def select_current_output(self):
        """Select the configured values for both dropdowns."""
        with self.dropdown_handlers_disabled():
            index, card = get_current_card('pcm_output')
            if card is not None:
                card_selection = self.card_selection
                if card_selection.get_active() != index:
                    card_selection.set_active(index)

    def populate_output_cards_dropdown(self):
        """Get all output options and fill them into the dropdowns."""
        with self.dropdown_handlers_disabled():
            cards = get_cards()
            self.card_selection.remove_all()
            for card in cards:
                self.card_selection.append(card, card)
            # since all cards have been removed, restore the selection
            index, card = get_current_card('pcm_output')
            if card is not None:
                self.card_selection.set_active(index)

    def on_output_card_selected(self, card_dropdown):
        """Handler for when a card is selected or the list just changed."""
        if not output_exists():
            play_silence()

        card_name = card_dropdown.get_active_text()
        if card_name is None:
            return
        if get_current_card('pcm_output')[1] == card_name:
            # already at the correct selection
            return
        select_output_pcm(card_name)

    @only_with_existing_output
    def on_output_volume_change(self, gtk_range):
        """Handler when the output volume slider was dragged."""
        muted = is_muted()
        volume = gtk_range.get_value()
        self.refresh_icon_state('output', volume, muted)
        set_volume(volume, alsaaudio.PCM_PLAYBACK, nonlinear=True)

    @only_with_existing_output
    def on_mute_output_clicked(self, button):
        """Handler for when the mute button was clicked."""
        muted = button.get_active()
        set_mute(OUTPUT_MUTE, muted)
        volume = get_volume(alsaaudio.PCM_PLAYBACK, nonlinear=True)
        self.refresh_icon_state('output', volume, muted)

    @only_with_existing_output
    def on_test_speaker_clicked(self, _):
        """Handler when the speaker test button was pressed."""
        self.bindings.toggle_speaker_test()
        # after some delay check if it is still running,
        # to show potential errors
        GLib.timeout_add(100, self.check_speaker_test)

    def check_speaker_test(self):
        """Adjust the GUI to the speaker test state."""
        state, error = self.bindings.check_speaker_test()

        builder = self.builder
        button = builder.get_object('output_test')
        speaker_test_error = builder.get_object('speaker_test_error')
        speaker_test_error_text = builder.get_object('speaker_test_error_text')

        if error:
            # Show it in an extra label, not a dialog, because I think
            # they are annoying.
            speaker_test_error.show()
            advice = get_error_advice(error)
            if advice is not None:
                speaker_test_error_text.set_label(
                    f'{error}\n\nHelp:\n{advice}'
                )
            else:
                speaker_test_error_text.set_label(error)
        else:
            speaker_test_error.hide()

        if state:
            button.set_label('Stop Test')
            return True  # keep the timeout running
        else:
            button.set_label('Test Speaker')
            return False

    """Input"""

    def populate_input_pcms(self):
        """Create the list of intput cards."""
        self.stop_input_levels()

        for input_card in self.input_rows:
            input_card.destroy()
        self.input_rows = []

        input_cards_list = self.builder.get_object('input_cards_list')

        cards = get_cards()
        for card in cards:
            # for each possible output, construct an InputRow, which also
            # figures out if the card is usable as input.
            input_row = InputRow(card, self.select_input_card)
            if input_row.is_valid():
                # If it can be used, register it so that it
                # can be manipulated
                input_cards_list.pack_start(
                    input_row.get_widget(),
                    expand=False, fill=False, padding=10
                )
                self.input_rows.append(input_row)

    def select_input_card(self, card):
        """Select a card as input source."""
        if not input_exists():
            record_to_nowhere()

        label = self.builder.get_object('input_card_name')
        label.set_label(card)
        for input_row in self.input_rows:
            if input_row.card != card:
                input_row.set_active(0)
            else:
                input_row.set_active(1)

        select_input_pcm(card)

    @only_with_existing_input
    def on_input_volume_change(self, gtk_range):
        """Handler when the input volume slider was dragged."""
        muted = is_muted(INPUT_MUTE)
        volume = gtk_range.get_value()
        self.refresh_icon_state('input', volume, muted)
        set_volume(volume, alsaaudio.PCM_CAPTURE, nonlinear=True)

    @only_with_existing_input
    def on_mute_input_clicked(self, button):
        """Handler for when the mute button was clicked."""
        muted = button.get_active()
        set_mute(INPUT_MUTE, muted)
        volume = get_volume(alsaaudio.PCM_CAPTURE, nonlinear=True)
        self.refresh_icon_state('input', volume, muted)

    def stop_input_levels(self):
        """Stop all loops that monitor input levels."""
        for input_level in self.input_levels:
            input_level.stop()
        self.input_levels = []

    def select_current_input(self):
        """Select the configured input."""
        card = get_current_card('pcm_input')[1]
        if card is not None:
            self.select_input_card(card)


if __name__ == '__main__':
    set_bus(DBusGMainLoop())
    ALSAControlWindow()
    Gtk.main()
