#!/usr/bin/python3
# -*- coding: utf-8 -*-
# ALSA-Control - ALSA configuration interface
# Copyright (C) 2020 sezanzeb <proxima@hip70890b.de>
#
# This file is part of ALSA-Control.
#
# ALSA-Control is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# ALSA-Control is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with ALSA-Control.  If not, see <https://www.gnu.org/licenses/>.


"""User Interface."""


import os

import alsaaudio
import gi
gi.require_version('Gtk', '3.0')
gi.require_version('GLib', '2.0')
from gi.repository import Gtk, GLib

from alsacontrol.alsa import get_volume, set_volume, toggle_mute, is_muted, \
    get_devices, get_outputs, get_device, get_output
from alsacontrol.bindings import Bindings, get_volume_string, \
    get_volume_icon, get_error_advice, select_pcm
from alsacontrol.data import get_data_path
from alsacontrol.config import get_config


class ALSAControlWindow:
    """User Interface."""
    def __init__(self):
        self.bindings = Bindings()

        gladefile = os.path.join(get_data_path(), 'alsacontrol.glade')
        builder = Gtk.Builder()
        builder.add_from_file(gladefile)
        builder.connect_signals(self)
        self.builder = builder

        self.initialize_volume_slider()
        self.populate_devices_dropdown()

        self.speaker_test_process = None

        window = builder.get_object('alsacontrol_window')
        window.show_all()

        speaker_test_error = builder.get_object('speaker_test_error')
        speaker_test_error.hide()

        GLib.timeout_add(1000, self.refresh_devices)

        Gtk.main()

    def refresh_devices(self):
        """Refresh the list of devices for both input and output."""
        if self.bindings.log_new_pcms():
            self.populate_devices_dropdown()
        return True

    def populate_devices_dropdown(self):
        """Get all output options and fill them into the dropdowns."""
        device_selection = self.builder.get_object('output_device_selection')
        devices = get_devices(alsaaudio.PCM_PLAYBACK)  # alsaaudio.cards()
        device_selection.remove_all()
        for device in devices:
            device_selection.append(device, device)

        # select the currently used device
        active = get_device(get_config().get('pcm_output', 'null'))
        if active in devices:
            active_index = devices.index(active)
            if device_selection.get_active() != active_index:
                print('set_active', device_selection.get_active(), active_index)
                device_selection.set_active(active_index)

    def populate_modes_dropdown(self, device):
        """For the selected device, write the options into the UI."""
        output_selection = self.builder.get_object('output_mode_selection')
        output_selection.remove_all()

        if device is None:
            return

        outputs = get_outputs(device, alsaaudio.PCM_PLAYBACK)

        if len(outputs) == 0:
            # no options exist for this device
            select_pcm(device, None)
            return

        for output in outputs:
            output_selection.append(output, output)

        # select the currently used output
        active = get_output(get_config().get('pcm_output', 'null'))
        if active in outputs:
            active_index = outputs.index(active)
            if output_selection.get_active() != active_index:
                output_selection.set_active(active_index)

    def on_device_selected(self, device):
        self.populate_modes_dropdown(device.get_active_text())

    def on_mode_selected(self, output):
        """Actually set the current default pcm."""
        output = output.get_active_text()
        if output is None:
            # happens when the device is changed
            return

        output_selection = self.builder.get_object('output_mode_selection')
        device_selection = self.builder.get_object('output_device_selection')
        device = device_selection.get_active_text()
        output = output_selection.get_active_text()
        select_pcm(device, output)

    def initialize_volume_slider(self):
        """Reflect the current volume."""
        # this will trigger output_volume_change
        output_slider = self.builder.get_object('output_volume_slider_scale')
        output_volume = get_volume(alsaaudio.PCM_PLAYBACK, nonlinear=True)
        output_slider.set_value(output_volume)

        input_slider = self.builder.get_object('input_volume_slider_scale')
        input_volume = get_volume(alsaaudio.PCM_CAPTURE, nonlinear=True)
        input_slider.set_value(input_volume)

    def on_output_volume_change(self, gtk_range):
        """The volume slider in the "Output Device" tab was dragged."""
        muted = is_muted()
        volume = gtk_range.get_value()
        self.refresh_output_state(volume, muted)
        set_volume(volume, alsaaudio.PCM_PLAYBACK, nonlinear=True)

    def on_mute_output_pressed(self, _):
        """The mute button was pressed."""
        muted = toggle_mute()
        volume = get_volume(alsaaudio.PCM_PLAYBACK, nonlinear=True)
        self.refresh_output_state(volume, muted)

    def on_test_speaker_clicked(self, _):
        """Test the speaker setup by playing sounds."""
        self.bindings.toggle_speaker_test()
        # after some delay check if it is still running,
        # to show potential errors
        GLib.timeout_add(100, self.check_speaker_test)

    def check_speaker_test(self):
        """Adjust the GUI to the speaker test state."""
        state, error = self.bindings.check_speaker_test()

        builder = self.builder
        button = builder.get_object('output_test')
        speaker_test_error = builder.get_object('speaker_test_error')
        speaker_test_error_text = builder.get_object('speaker_test_error_text')

        if error:
            # Show it in an extra label, not a dialog, because I think
            # they are annoying.
            speaker_test_error.show()
            advice = get_error_advice(error)
            if advice is not None:
                speaker_test_error_text.set_label(
                    '{}\n\n{}'.format(error, advice)
                )
            else:
                speaker_test_error_text.set_label(error)
        else:
            speaker_test_error.hide()

        if state:
            button.set_label('Stop Test')
            return True
        else:
            button.set_label('Test Speaker')
            return False

    def refresh_output_state(self, volume, muted):
        """Refresh icons and labels depending on mute and volume state"""
        volume_string = get_volume_string(volume, muted)
        volume_label = self.builder.get_object('output_volume_current')
        volume_label.set_label(volume_string)

        volume_icon_name = get_volume_icon(volume, muted)
        volume_image = self.builder.get_object('output_volume_icon')
        volume_image.set_from_icon_name(volume_icon_name, Gtk.IconSize.BUTTON)

    def on_close(self, *_):
        """Safely close the application."""
        self.bindings.stop_speaker_test()
        Gtk.main_quit()

if __name__ == '__main__':
    ALSAControlWindow()
