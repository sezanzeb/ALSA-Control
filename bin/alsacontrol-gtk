#!/usr/bin/python3
# -*- coding: utf-8 -*-
# ALSA-Control - ALSA configuration interface
# Copyright (C) 2020 sezanzeb <proxima@hip70890b.de>
#
# This file is part of ALSA-Control.
#
# ALSA-Control is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# ALSA-Control is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with ALSA-Control.  If not, see <https://www.gnu.org/licenses/>.


"""User Interface."""


import os

import alsaaudio
import gi
gi.require_version('Gtk', '3.0')
gi.require_version('GLib', '2.0')
from gi.repository import Gtk, GLib

from alsacontrol.alsa import get_volume, set_volume, toggle_mute, is_muted, \
    get_devices, get_ports
from alsacontrol.bindings import Bindings, get_volume_string, \
    get_volume_icon, get_error_advice, select_pcm, get_current_output
from alsacontrol.data import get_data_path


class ALSAControlWindow:
    """User Interface."""
    def __init__(self):
        self.bindings = Bindings()

        gladefile = os.path.join(get_data_path(), 'alsacontrol.glade')
        builder = Gtk.Builder()
        builder.add_from_file(gladefile)
        builder.connect_signals(self)
        self.builder = builder

        self.device_selection = self.builder.get_object(
            'output_device_selection'
        )
        self.port_selection = self.builder.get_object(
            'output_port_selection'
        )

        self.initialize_volume_slider()
        self.populate_output_devices_dropdown()
        self.populate_input_pcms()
        self.select_current_output()

        self.speaker_test_process = None

        window = builder.get_object('alsacontrol_window')
        window.show()

        speaker_test_error = builder.get_object('speaker_test_error')
        speaker_test_error.hide()

        GLib.timeout_add(500, self.refresh_devices)

        Gtk.main()

    """General Stuff"""

    def on_close(self, *_):
        """Safely close the application."""
        self.bindings.stop_speaker_test()
        Gtk.main_quit()

    def refresh_devices(self):
        """Refresh the list of devices for both input and output."""
        if self.bindings.log_new_pcms():
            self.populate_output_devices_dropdown()
            self.populate_output_ports_dropdown()
            self.populate_input_pcms()
        return True

    def initialize_volume_slider(self):
        """Reflect the current volume."""
        # this will trigger output_volume_change
        output_slider = self.builder.get_object('output_volume_slider_scale')
        output_volume = get_volume(alsaaudio.PCM_PLAYBACK, nonlinear=True)
        output_slider.set_value(output_volume)

        input_slider = self.builder.get_object('input_volume_slider_scale')
        input_volume = get_volume(alsaaudio.PCM_CAPTURE, nonlinear=True)
        input_slider.set_value(input_volume)

    def on_switch_page(self, notebook, page, page_num):
        page_name = page.get_name()
        input_devices_scrolled_window = self.builder.get_object(
            'input_devices_scrolled_window'
        )
        if page_name == 'input_device_tab':
            input_devices_scrolled_window.show()
        else:
            # shrink the output tab height to the contents
            input_devices_scrolled_window.hide()
            window = self.builder.get_object('alsacontrol_window')
            window.resize(window.get_size()[0], 1)

    """Output"""

    def dropdown_handlers_disabled(self):
        """Safely modify dropdown contents.

        Use this in a with statement to avoid calling handlers when
        modifying the dropdown contents.
        """
        device_selection = self.device_selection
        port_selection = self.port_selection
        on_output_device_selected = self.on_output_device_selected
        on_output_port_selected = self.on_output_port_selected

        class dropdown_handlers_disabled:
            def __enter__(self):
                try:
                    device_selection.disconnect_by_func(
                        on_output_device_selected
                    )
                    port_selection.disconnect_by_func(
                        on_output_port_selected
                    )
                    self.was_connected = True
                except TypeError:
                    self.was_connected = False

            def __exit__(self, *_):
                if self.was_connected:
                    device_selection.connect(
                        'changed', on_output_device_selected
                    )
                    port_selection.connect(
                        'changed', on_output_port_selected
                    )

        return dropdown_handlers_disabled()

    def select_current_output(self):
        """Select the configured values for both dropdowns."""
        with self.dropdown_handlers_disabled():
            d, device, p, port = get_current_output()

            if device is not None:
                device_selection = self.device_selection
                if device_selection.get_active() != d:
                    device_selection.set_active(d)

            self.populate_output_ports_dropdown()

            if port is not None:
                output_selection = self.port_selection
                if output_selection.get_active() != p:
                    output_selection.set_active(p)

    def populate_output_devices_dropdown(self):
        """Get all output options and fill them into the dropdowns."""
        with self.dropdown_handlers_disabled():
            devices = get_devices(alsaaudio.PCM_PLAYBACK)
            self.device_selection.remove_all()
            for device in devices:
                self.device_selection.append(device, device)
            # since all devices have been removed, restore the selection
            index, device, _, _ = get_current_output()
            if device is not None:
                self.device_selection.set_active(index)

    def populate_output_ports_dropdown(self):
        """For the selected device, write the options into the UI."""
        with self.dropdown_handlers_disabled():
            device = self.device_selection.get_active_text()
            self.port_selection.remove_all()
            if device is None:
                return
            ports = get_ports(device, alsaaudio.PCM_PLAYBACK)
            if len(ports) == 0:
                # no options exist for this device
                select_pcm(device, None)
                return
            for port in ports:
                self.port_selection.append(port, port)

            # since all ports have been removed, restore the selection
            _, _, index, port = get_current_output()
            if port is not None:
                self.port_selection.set_active(index)

    def on_output_device_selected(self, device_dropdown):
        """Handler for when a device is selected or the list just changed."""
        device_name = device_dropdown.get_active_text()
        if device_name is None:
            return
        if get_current_output()[1] == device_name:
            # already at the correct selection
            return

        self.populate_output_ports_dropdown()
        # select the sysdefault port by default if possible
        ports = get_ports(device_name, alsaaudio.PCM_PLAYBACK)
        if 'sysdefault' in ports:
            self.port_selection.set_active(ports.index('sysdefault'))

    def on_output_port_selected(self, port_dropdown):
        """Handler that actually sets the current default pcm."""
        port_name = port_dropdown.get_active_text()
        if port_name is None:
            return
        device_selection = self.device_selection
        device = device_selection.get_active_text()
        select_pcm(device, port_name)

    def on_output_volume_change(self, gtk_range):
        """Handler when the output volume slider was dragged."""
        muted = is_muted()
        volume = gtk_range.get_value()
        self.refresh_output_state(volume, muted)
        set_volume(volume, alsaaudio.PCM_PLAYBACK, nonlinear=True)

    def on_mute_output_pressed(self, _):
        """Handler for when the mute button was pressed."""
        muted = toggle_mute()
        volume = get_volume(alsaaudio.PCM_PLAYBACK, nonlinear=True)
        self.refresh_output_state(volume, muted)

    def on_test_speaker_clicked(self, _):
        """Handler when the speaker test button was pressed."""
        self.bindings.toggle_speaker_test()
        # after some delay check if it is still running,
        # to show potential errors
        GLib.timeout_add(100, self.check_speaker_test)

    def check_speaker_test(self):
        """Adjust the GUI to the speaker test state."""
        state, error = self.bindings.check_speaker_test()

        builder = self.builder
        button = builder.get_object('output_test')
        speaker_test_error = builder.get_object('speaker_test_error')
        speaker_test_error_text = builder.get_object('speaker_test_error_text')

        if error:
            # Show it in an extra label, not a dialog, because I think
            # they are annoying.
            speaker_test_error.show()
            advice = get_error_advice(error)
            if advice is not None:
                speaker_test_error_text.set_label(
                    '{}\n\n{}'.format(error, advice)
                )
            else:
                speaker_test_error_text.set_label(error)
        else:
            speaker_test_error.hide()

        if state:
            button.set_label('Stop Test')
            return True  # keep the timeout running
        else:
            button.set_label('Test Speaker')
            return False

    def refresh_output_state(self, volume, muted):
        """Refresh icons and labels depending on mute and volume state"""
        volume_string = get_volume_string(volume, muted)
        volume_label = self.builder.get_object('output_volume_current')
        volume_label.set_label(volume_string)

        volume_icon_name = get_volume_icon(volume, muted)
        volume_image = self.builder.get_object('output_volume_icon')
        volume_image.set_from_icon_name(volume_icon_name, Gtk.IconSize.BUTTON)

    """Input"""

    def populate_input_pcms(self):
        """Create the list of intput devices."""
        input_devices_list = self.builder.get_object('input_devices_list')
        devices = get_devices(alsaaudio.PCM_CAPTURE)
        for device in devices:
            ports = get_ports(device, alsaaudio.PCM_CAPTURE) or ['']
            for port in ports:
                level = Gtk.ProgressBar()
                level.set_valign(Gtk.Align.CENTER)
                select_button = Gtk.Button.new_from_icon_name(
                    'object-select', Gtk.IconSize.BUTTON
                )
                pcm_name = Gtk.Label(
                    label='{} {}'.format(device, port or '')
                )
                pcm_name.set_xalign(0.0)

                box = Gtk.Box(
                    orientation=Gtk.Orientation.HORIZONTAL,
                    spacing=10
                )
                box.pack_start(
                    pcm_name, expand=True, fill=True, padding=0
                )
                box.pack_start(
                    level, expand=False, fill=False, padding=0
                )
                box.pack_start(
                    select_button, expand=False, fill=True, padding=0
                )
                box.set_margin_start(10)
                box.set_margin_end(22)

                box.show_all()

                input_devices_list.pack_start(
                    box, expand=False, fill=False, padding=10
                )


if __name__ == '__main__':
    ALSAControlWindow()
